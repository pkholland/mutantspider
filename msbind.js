/*
  General Concept: called by 'make' to help in a variety of tasks related to building a mutantspider component.
  
  This script uses the 'ctags' utility to parse a set of C/C++ header and source files in order to understand
  what functions are supposed to be callable by javascript into C and what functions are supposed to be callable
  by C into javascript.  It parses things like the function names as well as arguments and argument types.  With this
  parsed it is then able to construct a variety of helper snippets that the mutantspider build system uses when
  building components.  The different things that it does are controlled by setting the "task" command line argument
  to one of:
 
  
  write_make_rules
  
      This task creates make rules for the files "interface_glue.cpp", "ibrary_glue.js", and "<component>-bind.js".
      These are three files that are automatically generated by the build system.  interface_glue.cpp contains
      C++ code that handles certain steps in receiving api call data from javascript, parsing that data, determining
      what C++ function is being requested and then calling that function along with the given arguments.  This C++
      file is used by both emcc and pnacl builds, although a majority of its contents are pnacl-specific.
      library_glue.js is an emcc-style "library" file that calling from C++ into javascript in the case where the
      C++ code is _not_ running as a web worker.  <component>-bind.js is a node module that contains javascript glue
      code for calling from javascript to C++.
      
      The write_make_rules task generates a string, written to stdout, that contains the rules discussed above.
      make calls $(eval xxx) on that returned string.  The recipe steps in that returned string contain (among
      other things) additional calls to to this script, specifying other tasks.
 
      
  write_c_snippet
  
      This task creates the content of the interface_glue.cpp file by copying some boilerplate content and
      then filling out the rest of the file with C++ code that is specific to the set of functions that are
      being exported from C (and so callable from javascript)
      
  write_js_library
  
      This task creates the content of the ibrary_glue.js file.
 
      
  write_bind
  
      This task creates the content of the <component>-bind.js file, where "component" is the name of the C++
      component you are building - specified to make by setting the ms.BUILD_NAME make variable - so in make
      syntax, the name of this file is $(ms.BUILD_NAME)-bind.js.  It contains the javascript side for the glue
      code that calls from javascript into a C++ component.
 
      
  write_em_exports
  
      This task returns a string with the names of all of the exported C++ functions.  This used as an input to
      the link-like call to emcc so that emcc knows what functions need to be reachable by Module.cwrap/ccall.
  
*/

"use strict"

let fs = require('fs');
let path = require('path');
let child_process = require('child_process');
let argv = require('minimist')(process.argv.slice(2));
let ms = require('./mutantspider.js');

// since this can be called by both "first-pass" (where the returned string is evaluated by make) and second pass
// if the parameters don't include a task - which is what lets this script know whether it is first pass or not
// we write an error message that contains the code to stop make from processing - in case it is first-pass.
// If this is not first pass, meaning that stdout is being piped to some file, then it ends up with this extra
// code in it.
ms.make_assert(!argv.task, "error: must specify --task=<some task>");

let first_pass_make = argv.task === 'write_make_rules';
let do_assert = first_pass_make ? ms.make_assert : ms.assert;

do_assert(!argv.config_file, "error: must specify --config_file=<some configuration file>");
if (first_pass_make)
  do_assert(!argv.component_name, "error: must specify --component_name=<some name> if you have specified --task=write_make_rules");


// read the config_file into a string and call us back with that string
ms.read_file_and_start(argv.config_file, first_pass_make, (config_str) => {

  // any uncaught exception results in writing
  // the error text to stdout, and then exiting the
  // process with a non-zero exit code
  try {
  
    let exported_c_functions = [];
    let exported_js_functions = [];
    
    // MacOS comes with an older version of ctags, so display this helpful message letting
    // the user know that they should check their version of ctags.
    function show_make_error() {
      console.error('');
      console.error('If you are seeing a ctags error complaining about unknown options');
      console.error('or "invalid return type, must be void", you may need to install the');
      console.error('\'exuberant\' version of ctags.  The default version installed on');
      console.error('Mac OS is not capable of parsing the code the way we want it parsed.');
      console.error('to test if you have any version of ctags installed, try executing "which ctags"');
      console.error('If this doesn\'t print anything, or on Mac OS X, if it shows /usr/bin/ctags');
      console.error('you will need to install the exuberant one.  The exuberant one responds');
      console.error('"ctags --help" with an actual help listing.  The default Mac OS X one');
      console.error('complains about --help being an invalid option.  Assuming you already');
      console.error('have Homebrew installed you can install the exuberant ctags by executing');
      console.error('');
      console.error('brew install ctags-exuberant');
      console.error('');
      console.error('If this fails due to an inability to write to your /usr/local/include');
      console.error('directory you can fix that by either making that directory writable by');
      console.error('everyone, or by changing the owner of that directory to you, using chown');
      console.error('');
      console.error('Also, note that you may need to exit and restart your terminal window');
      console.error('before it will correctly use the one you just installed');
      console.error('');
      console.error('In Ubuntu Linux you can install it by executing:');
      console.error('');
      console.error('sudo apt-get install exuterant-ctags');
      console.error('');
      console.log('$(error )');
    }
    
    // helper to call spawnSync and handle error codes
    function spawn_sync_check(exe, args, options) {
      let p = child_process.spawnSync(exe, args, options);
      if (p.status !== 0) {
        if (first_pass_make) {
          var lines = p.stderr.toString().split('\n');
          for (var l in lines)
            console.error(lines[l]);
          show_make_error();
        }
        process.exit(p.status);
      }
      return p;
    }
    
    // world's simplest (and least correct) tokenizer
    function find_first_ws(line) {
      for (let i = 0, c; c = line[i]; i++) {
        if (c === ' ' || c === '\t')
          return i;
      }
      return -1;
    }
    
    // world's simplest (and least correct) tokenizer
    function find_first_nws(line) {
      for (let i = 0, c; c = line[i]; i++) {
        if (c !== ' ' && c !== '\t')
          return i;
      }
      return -1;
    }
    
    // world's simplest (and least correct) tokenizer
    function tok_boundary(c) {
      return c === ' ' || c === '\t' || c === '(' || c === ')'
            || c === '{' || c === '}' || c === '[' || c === ']'
            || c === '<' || c === '>' || c === '.' || c === '/'
            || c === '+' || c === '-' || c === '*' || c === '\''
            || c === '"' || c === '\\' || c === '!' || c === '&'
            || c === '&' || c === '?' || c === ',' || c === ';'
            || c === ':' || c === '\n' || c === '\r';
    }
    
    // world's simplest (and least correct) tokenizer
    function next_token(buffer, pos) {
      while (pos < buffer.length && (buffer[pos] === ' ' || buffer[pos] === '\t' || buffer[pos] === '\n'))
        ++pos;
      if (pos >= buffer.length)
        return {done: true};
      let start_pos = pos;
      if (!tok_boundary(buffer[pos])) {
        ++pos;
        while (pos < buffer.length && !tok_boundary(buffer[pos]))
          ++pos;
      } else
        ++pos;
      return {pos:pos, tok:buffer.substring(start_pos, pos)};
    }
    
    // given 'buffer' that contains the entire contents of a .cpp or .h file and 'line_number' that
    // is the line number at which a function definition starts in that file, parse that function definition
    // and return some information about it.
    function parse_source_function(buffer, line_number) {
    
      // locate the start of the specified line in the given buffer
      let ln = 0;
      let pos = 0;
      while (ln < line_number) {
        pos = buffer.indexOf('\n', pos);
        do_assert(pos === -1,'couldn\'t fine line ' + line_number + ' in file');
        ++pos;
        ++ln;
      }
      
      // 'pos' is now the byte offset into the file where the function definition starts
      let tk = next_token(buffer, pos);
      let ret_type = tk.tok;
      do_assert(ret_type !== 'void', 'invalid return type (' + ret_type + '), must be \'void\'');
      tk = next_token(buffer, tk.pos);
      let func_name = tk.tok;
      do_assert(tok_boundary(func_name[0]), 'invalid function name: ' + func_name);

      // advance until the start of the parameter set
      tk = next_token(buffer, tk.pos);
      do_assert(tk.tok !== '(', 'syntax error 1');

      let args = [];
      
      tk = next_token(buffer, tk.pos);
      let p_type = '';
      
      // loop through all parameters
      while (tk.tok !== ')') {
      
        p_type = p_type + tk.tok;
        if (tk.tok === 'const') {
          p_type += ' ';
          tk = next_token(buffer, tk.pos);
          continue;
        }
        
        do_assert(tok_boundary(p_type[0]), 'syntax error 2');
        tk = next_token(buffer, tk.pos);
        
        while (tk.tok === '*' || tk.tok === '&') {
          p_type += tk.tok;
          tk = next_token(buffer, tk.pos);
        }
        
        var p_name = '';
        if (tk.tok !== ',' && tk.tok !== ')') {
          p_name = tk.tok;
          tk = next_token(buffer, tk.pos);
        }
        if (tk.tok === ',')
          tk = next_token(buffer, tk.pos);
        
        // push the next argment
        args.push({type: p_type, name: p_name});
        p_type = '';
        
      }
      
      return {ret_type: ret_type, name: func_name, args: args};
    }
    
    // given 'line' as one text line of output from ctags, and 'buffer' as the entire contents
    // of the .cpp or .h file that ctags processed, locate and parse the function referred to in 'line'
    function process_ctag_line(line, buffer) {
      let fname = line.substring(0,find_first_ws(line));
      line = line.substring(find_first_ws(line));
      line = line.substring(find_first_nws(line));
      let symbol_type = line.substring(0,find_first_ws(line));
      line = line.substring(find_first_ws(line));
      line = line.substring(find_first_nws(line));
      let line_number = parseInt(line.substring(0,find_first_ws(line)));
      line = line.substring(find_first_ws(line));
      line = line.substring(find_first_nws(line));
      let file_name = line.substring(0,find_first_ws(line));
      
      return parse_source_function(buffer, line_number-1);
    }
    
    // process either the javascript -> c++ calls or the c++ -> javascript calls
    function do_file_set(files, functions, is_cpp, list) {
      files.forEach((file_name) => {
        let args = [];
        if (!is_cpp)
          args.push('--c-types=p')
        args.push('-x');
        let full_file_name = path.join(path.dirname(argv.config_file), file_name);
        args.push(full_file_name);
        let ret = spawn_sync_check('ctags', args);
        let lines = ret.stdout.toString().split('\n');
        
        let stats = fs.statSync(full_file_name);
        let buffer = new Buffer(stats.size);
        let fd = fs.openSync(full_file_name, 'r');
        fs.readSync(fd, buffer, 0, stats.size);
        fs.close(fd);
        let buffer_string = buffer.toString();
        
        // walk through each line of ctag output
        lines.forEach((line) => {
          // walk through each function listed as an export in the config file
          functions.forEach((fn) => {
            // does the listed function end with the wildcard character?
            if (fn[fn.length-1] === '*') {
              if (line.indexOf(fn.substring(0,fn.length-1))  === 0)
                list.push(process_ctag_line(line, buffer_string));
            } else {
              let fname = line.substring(0,find_first_ws(line));
              if (fname === fn)
                list.push(process_ctag_line(line, buffer_string));
            }
          });
        });
        
      });
    }
    
    // is the p'th argument in args a "memory buffer" argument for js->c?
    //
    // a js->c "memory buffer" argument is a tripplet of arguments that look like:
    //
    //      void* foo, size_t foo_size, ms_transfered_buffer* foo_free
    //
    //  for some "foo" name.
    function is_mem_buff_param_to_c(args, p) {
      return ((args[p].type === 'void*' || args[p].type === 'const void*')
              && (p < args.length - 2)
              && (args[p+1].type === 'size_t') && (args[p+1].name === (args[p].name + '_size'))
              && (args[p+2].type === 'ms_transfered_buffer*') && (args[p+2].name === (args[p].name + '_free')));
    }
    
    // does the given function 'f' contain one or more js->c "memory buffer" arguments?
    function has_mem_buff_param_to_c(f) {
      for (let p = 0; p < f.args.length; p++) {
        if (is_mem_buff_param_to_c(f.args, p))
          return true;
      }
      return false;
    }
    
    // is the p'th argument in args a "memory buffer" argument for js->c?
    //
    // a c->js "memory buffer" argument is a pair of arguments that look like:
    //
    //      void* foo, size_t foo_size
    //
    //  for some "foo" name.
    function is_mem_buff_param_to_js(args, p) {
      return ((args[p].type === 'void*' || args[p].type === 'const void*')
              && (p < args.length - 1)
              && (args[p+1].type === 'size_t') && (args[p+1].name === (args[p].name + '_size')));
    }
    
    // does the given function 'f' contain one or more c->js "memory buffer" arguments?
    function has_mem_buff_param_to_js(f) {
      for (let p = 0; p < f.args.length; p++) {
        if (is_mem_buff_param_to_js(f.args, p))
          return true;
      }
      return false;
    }
    
    // construct and return a string what is the names of all of the parameters in 'args'
    // separated by comma's (the way you would do for calling a function)
    function emit_param_names(args, stringify) {
      let str = '';
      let first = true;
      args.forEach((arg) => {
        if (first)
          first = false;
        else
          str += ', ';
        if (stringify && arg.type === 'const char*')
          str += 'Pointer_stringify(' + arg.name + ')';
        else
          str += arg.name;
      });
      return str;
    }
    
    function write_c_snippet() {
      console.log('');
      console.log('// auto-generated from - do not edit');
      console.log('');
      
      // some native cient only code
      console.log('#if defined(__native_client__)');
      console.log('');
      
      // write a function prototype for each C function
      console.log('extern "C" {');
      exported_c_functions.forEach((f) => {
        let str = '  ' + f.ret_type + ' ' + f.name + '(';
        let first = true;
        f.args.forEach((p) => {
          if (first)
            first = false;
          else
            str += ', ';
          str += p.type;
        });
        str += ');';
        console.log(str);
      });
      console.log('}');
      console.log('');
      
      // write the initDispatchMap function to load all of the
      // above functions into map_
      console.log('');
      console.log('void msinstance::initDispatchMap()');
      console.log('{');
      
      // each function in the map is a lambda that copies a parameter
      // out of the "d.args" array and passes them to the C function
      exported_c_functions.forEach((f) => {
        let pi = 0;
        console.log('  map_["' + f.name + '"] = [](const pp::VarDictionary& d)');
        console.log('  {');
        console.log('    pp::VarArray  args_(d.Get("args"));');
        for (let p = 0; p < f.args.length; p++) {
          let ppv_name = 'pv' + pi;
          if (is_mem_buff_param_to_c(f.args, p)) {
            console.log('    auto ' + ppv_name + ' = new pp::VarArrayBuffer(args_.Get(' + pi + '));');
            console.log('    auto p' + pi + ' = ' + ppv_name + '->Map();');
            p += 2;
          } else {
            console.log('    pp::Var ' + ppv_name + '(args_.Get(' + pi + '));');
            let str =   '    auto p' + pi + ' = ' + ppv_name + '.';
            if (f.args[p].type === 'int')
              str += 'AsInt();';
            else if (f.args[p].type === 'double')
              str += 'AsDouble();';
            else if (f.args[p].type === 'const char*')
              str += 'AsString();';
            else
              do_assert(true, 'unsupported parameter type: \'' + f.args[p].type + '\'');
            console.log(str);
          }
          pi++;
        }
        pi = 0;
        let str = '    ' + f.name + '(';
        for (let p = 0; p < f.args.length; p++) {
          str += 'p' + pi;
          if (is_mem_buff_param_to_c(f.args, p)) {
            str += ', pv' + pi + '->ByteLength(), (ms_transfered_buffer*)pv' + pi;
            p += 2;
          } else if (f.args[p].type === 'const char*')
            str += '.c_str()';
          if (p < f.args.length-1)
            str += ', ';
          pi++;
        }
        str += ');';
        console.log(str);
        console.log('  };');
      });

      console.log('}');
      console.log('');
      
      // for each javascript function that is callable from C...
      console.log('extern "C" {');
      console.log('');
      
      exported_js_functions.forEach((f) => {

        // the function definition
        let str = 'void ' + f.name + '(';
        for (let p = 0, arg; arg = f.args[p]; p++) {
          str += arg.type + ' ' + arg.name;
          if (p < f.args.length -1)
            str += ', ';
        }
        console.log(str + ')');
        
        // the function body
        console.log('{');
        
        // to start with, for any parameter that is a memory buffer,
        // declare a VarrArrayBuffer for it and copy the supplied memory
        // into it.
        for (let p = 0, arg; arg = f.args[p]; p++) {
          if (is_mem_buff_param_to_js(f.args, p)) {
            let bn = arg.name + '_buff_';
            console.log('  pp::VarArrayBuffer  ' + bn + '(' + f.args[p+1].name + ');');
            console.log('  memcpy(' + bn + '.Map(), ' + arg.name + ', ' + f.args[p+1].name + ');');
            console.log('  ' + bn + '.Unmap();');
            p += 1;
          }
        }
        
        // declare the 'args' VarArray we fill out as part of the call
        console.log('  pp::VarArray args;');
        
        // copy all parameter values into 'args'
        let pi = 0;
        for (let p = 0, arg; arg = f.args[p]; p++) {
          if (is_mem_buff_param_to_js(f.args, p)) {
            console.log('  args.Set(' + pi + ',' + arg.name + '_buff_);');
            p += 1;
          } else
            console.log('  args.Set(' + pi + ',' + arg.name + ');');
          ++pi;
        }
        console.log('');
        
        // now the dictionary itself that we will send (via PostMessage)
        console.log('  pp::VarDictionary msg_;');
        console.log('  msg_.Set("api","' + f.name + '");');
        console.log('  msg_.Set("args",args);');
        console.log('  gGlobalPPInstance->PostMessage(msg_);');
        
        console.log('}');
        console.log('');

      
      });
      
      // some boilerplate code
      console.log('void ms_async_startup_complete(const char* err)');
      console.log('{');
      console.log('  pp::VarArray args;');
      console.log('  args.Set(0,gModuleID);');
      console.log('  if (err)');
      console.log('    args.Set(1,std::string(err));');
      console.log('');
      console.log('  pp::VarDictionary msg;');
      console.log('  if (err)');
      console.log('    msg.Set("api","ms_async_startup_failed");');
      console.log('  else');
      console.log('    msg.Set("api","ms_async_startup_complete");');
      console.log('  msg.Set("args",args);');
      console.log('  gGlobalPPInstance->PostMessage(msg);');
      console.log('}');
      console.log('');
      
      console.log('void ms_consolelog(const char* message)');
      console.log('{');
      console.log('  pp::VarArray args;');
      console.log('  args.Set(0,std::string(message));');
      console.log('');
      console.log('  pp::VarDictionary msg;');
      console.log('  msg.Set("api","consolelog");');
      console.log('  msg.Set("args",args);');
      console.log('  gGlobalPPInstance->PostMessage(msg);');
      console.log('}');
      console.log('');
      
      console.log('}');
      console.log('');
      
      console.log('#endif // defined(__native_client__)');
      console.log('');
    }
    
    function write_js_library() {
      console.log('');
      console.log('// auto-generated from - do not edit');
      console.log('');
      console.log('mergeInto(LibraryManager.library, {');
      
      exported_js_functions.forEach((f) => {
      
        // the function signature
        let str = '  ' + f.name + '__sig:\'v';
        f.args.forEach((arg) => {
          if (arg.type === 'int')
            str += 'i';
          else if (arg.type === 'float')
            str += 'f';
          else if (arg.type === 'double')
            str += 'd';
          else if (arg.type === 'const char*')
            str += 'i';
          else if (arg.type === 'const void*')
            str += 'i';
          else if (arg.type === 'size_t')
            str += 'i';
          else
            do_assert(true, 'unsupported parameter type: \'' + arg.type + '\'');
        });
        console.log(str + '\',');
        
        // now the library function itself
        console.log('  ' + f.name + ': function(' + emit_param_names(f.args, false) + ') {');

        if (has_mem_buff_param_to_js(f)) {
        
          for (let p = 0, arg; arg = f.args[p]; p++) {
            if (is_mem_buff_param_to_js(f.args, p)) {
              console.log('    var ' + arg.name + '_arr_ = new Uint8Array(Module.HEAP8.buffer, ' + arg.name + ', ' + f.args[p+1].name + ');');
              p += 1;
            }
          }
          
          console.log('    if (typeof importScripts === \'function\') {');
          for (let p = 0, arg; arg = f.args[p]; p++) {
            if (is_mem_buff_param_to_js(f.args, p)) {
              console.log('      var ' + arg.name + '_arrb_ = new ArrayBuffer(' + arg.name + '_size);');
              console.log('      var ' + arg.name + '_copy_ = new Uint8Array(' + arg.name + '_arrb_);');
              console.log('      ' + arg.name + '_copy_.set(' + arg.name + '_arr_);');
              p += 1;
            }
          }
          
          str = '      postMessage({api:\'' + f.name + '\', args:[';
          for (let p = 0; p < f.args.length; p++) {
            str += f.args[p].name;
            if (is_mem_buff_param_to_js(f.args, p)) {
              str += '_copy_';
              p += 1;
            }
            if (p < f.args.length - 1)
              str += ', ';
          }
          str += ']}, [';
          let first = true;
          for (let p = 0, arg; arg = f.args[p]; p++) {
            if (is_mem_buff_param_to_js(f.args, p)) {
              if (!first)
                str += ', ';
              first = false;
              str += arg.name + '_copy_.buffer';
              p += 1;
            }
          }
          console.log(str + ']);');
          
          console.log('    } else');
          str = '      Module.__ms_c_to_js_api__.' + f.name + '.apply(Module.__ms_this__, [';
          for (var p = 0; p < f.args.length; p++) {
            if (is_mem_buff_param_to_js(f.args, p)) {
              str += f.args[p].name + '_arr_';
              p += 1;
            } else
              str += f.args[p].name;
            if (p < f.args.length - 1)
              str += ', ';
          }
          console.log(str + ']);');
        
        } else {
          
          // the simpler (and more common) case of no memory buffer transfers
          console.log('    if (typeof importScripts === \'function\')');
          console.log('      postMessage({api:\'' + f.name + '\', args:[' + emit_param_names(f.args, true) + ']});');
          console.log('    else');
          console.log('      Module.__ms_c_to_js_api__.' + f.name + '.apply(Module.__ms_this__, [' + emit_param_names(f.args, true) + ']);');
          
        }
        
        console.log('  },');
        
      });
      
      console.log('  ms_async_startup_complete__sig: \'vi\',');
      console.log('  ms_async_startup_complete: function(err) {');
      
      console.log('    if (err) {');
      console.log('      var reason = Pointer_stringify(err);')
      console.log('      if (typeof importScripts === \'function\')');
      console.log('        postMessage({api:\'ms_async_startup_failed\', args:[Module.__ms_module_id__, reason]});');
      console.log('      else');
      console.log('        Module.__ms_c_to_js_api__.ms_async_startup_failed.apply(Module.__ms_this__, [Module.__ms_module_id__, reason]);');
      console.log('      return;');
      console.log('    }');
      console.log('');
      
      // load the Module's __ms_js_to_c_api__ member with function objects that are the result of calling
      // Module.cwrap for each exported C function
      console.log('    var o = (typeof importScripts === \'function\') ? {} : Module.__ms_js_to_c_api__;');
      console.log('    var module_malloc = Module.cwrap(\'malloc\', \'number\', [\'number\']);');
      
      exported_c_functions.forEach((f) => {
        if (has_mem_buff_param_to_c(f)) {
          let str = '    var ' + f.name + '_raw_ = Module.cwrap(\'' + f.name + '\', \'null\', [';
          for (let p = 0, arg; arg = f.args[p]; p++) {
            if (is_mem_buff_param_to_c(f.args, p)) {
              str += '\'number\', \'number\', \'number\'';
              p += 2;
            } else
              str += (arg.type === 'const char*') ? '\'string\'' : '\'number\'';
            if (p < f.args.length - 1)
              str += ', ';
          }
          console.log(str + ']);');
          str = '    o.' + f.name + ' = function(';
          for (let p = 0; p < f.args.length; p++) {
            str += f.args[p].name;
            if (is_mem_buff_param_to_c(f.args, p))
              p += 2;
            if (p < f.args.length - 1)
              str += ', ';
          }
          console.log(str + ') {');
          
          for (let p = 0, arg; arg = f.args[p]; p++) {
            if (is_mem_buff_param_to_c(f.args, p)) {
              console.log('      var ' + arg.name + '_ptr = module_malloc(' + arg.name + '.byteLength);');
              console.log('      var ' + arg.name + '_array = new Uint8Array(Module.HEAPU8.buffer, ' + arg.name + '_ptr, ' + arg.name + '.byteLength);');
              console.log('      ' + arg.name + '_array.set(new Uint8Array(' + arg.name + '));');
              p += 2;
            }
          }
          str = '      ' + f.name + '_raw_(';
          for (let p = 0, arg; arg = f.args[p]; p++) {
            if (is_mem_buff_param_to_c(f.args, p)) {
              str += arg.name + '_ptr, ' + arg.name + '.byteLength, 0';
              p += 2;
            } else
              str += arg.name;
            if (p < f.args.length - 1)
              str += ', ';
          }
          console.log(str + ');');
          
          console.log('    };');
       } else {
          let str = '    o.' + f.name + ' = Module.cwrap(\'' + f.name + '\', \'null\', [';
          for (let p = 0, arg; arg = f.args[p]; p++) {
            str += (arg.type === 'const char*') ? '\'string\'' : '\'number\'';
            if (p < f.args.length - 1)
              str += ', ';
          }
          console.log(str + ']);');
        }
      });
      
      console.log('    if (typeof importScripts === \'function\') {');
      console.log('      self.addEventListener(\'message\', function(e) {o[e.data.api].apply(this, e.data.args);}, false);');
      console.log('      self.postMessage({api:\'ms_async_startup_complete\', args:[Module.__ms_module_id__]});');
      console.log('    } else');
      console.log('      Module.__ms_c_to_js_api__.ms_async_startup_complete.apply(Module.__ms_this__, [Module.__ms_module_id__]);');
      console.log('  }');
      
      console.log('});');
    }
    
    function create_function_def(f) {
      let str = 'function(';
      for (let p = 0, arg; arg = f.args[p]; p++) {
        str += arg.name;
        if (is_mem_buff_param_to_c(f.args, p))
          p += 2;
        if (p < f.args.length - 1)
          str += ', ';
      }
      return str + ') {';
    }
    
    function create_postMessage(f) {
      let str = 'mod_obj.postMessage({api:\'' + f.name + '\', args:[';
      for (let p = 0, arg; arg = f.args[p]; p++) {
        str += arg.name;
        if (arg.type === 'int')
          str += ' | 0';
        else if (arg.type === 'double')
          str += ' * 1';
        if (is_mem_buff_param_to_c(f.args, p))
          p += 2;
        if (p < f.args.length - 1)
          str += ', ';
      }
      return str + ']}';
    }
    
    function create_postMessage_call(f) {
      return create_postMessage(f) + ');';
    }
    
    function write_bind() {
      console.log('');
      console.log('// auto-generated - do not edit');
      console.log('');
      
      console.log('module.exports.bind = function(c_to_js, mod_obj, ths) {');
      
      console.log('');
      
      let str = '  var fns = [\'ms_async_startup_complete\', \'ms_error\', \'ms_crash\'';
      if (exported_js_functions.length > 0)
        str += ', ';
      for (var fi = 0; fi < exported_js_functions.length; fi++) {
        str += '\'' + exported_js_functions[fi].name + '\'';
        if (fi < exported_js_functions.length - 1)
          str += ', ';
      }
      console.log(str + '];');
      console.log('  for (var p in fns) {');
      console.log('    if (typeof c_to_js[fns[p]] !== \'function\')');
      console.log('      throw \'missing function: \' + fns[p];');
      console.log('  }');
      console.log('');
      
      console.log('  if ((mod_obj instanceof Worker) || (mod_obj.type === \'application/x-pnacl\') || (mod_obj.type === \'application/x-nacl\')) {');
      console.log('');
      console.log('    var js_to_c = {};');
      exported_c_functions.forEach((f) => {
        if (has_mem_buff_param_to_c(f)) {
          console.log('    if (mod_obj instanceof Worker)');
          console.log('      js_to_c[\'' + f.name + '\'] = ' + create_function_def(f));
          str = '          ' + create_postMessage(f) + ', [';
          let first = true;
          for (let p = 0, arg; arg = f.args[p]; p++) {
            if (is_mem_buff_param_to_c(f.args, p)) {
              if (!first)
                str += ', ';
              first = false;
              str += arg.name;
              p += 2;
            }
          }
          console.log(str + ']);');
          console.log('      };');
          console.log('    else');
          console.log('      js_to_c[\'' + f.name + '\'] = ' + create_function_def(f));
          console.log('        ' + create_postMessage_call(f));
          console.log('      };');

        } else {
        
          console.log('    js_to_c[\'' + f.name + '\'] = ' + create_function_def(f));
          console.log('      ' + create_postMessage_call(f));
          console.log('    };');
          
        }
      });
      
      console.log('');
      console.log('    var obj = (mod_obj instanceof Worker) ? mod_obj : mod_obj.parentNode;');
      console.log('    obj.addEventListener(\'message\', function(e) {');
      console.log('      if (e.data.api === \'consolelog\')');
      console.log('        console.log(e.data.args[0]);');
      console.log('      else');
      console.log('        c_to_js[e.data.api].apply(ths, e.data.args);');
      console.log('    }, true);');
      console.log('    obj.addEventListener(\'error\', function(e) {c_to_js[\'ms_error\'](e.message);}, true);');
      console.log('    obj.addEventListener(\'crash\', function(e) {c_to_js[\'ms_crash\'](e.message);}, true);');
      console.log('    if (!(mod_obj instanceof Worker))');
      console.log('      document.body.appendChild(obj);');
      console.log('');
      console.log('    return js_to_c;');
      console.log('');
      
      console.log('  } else {');
      console.log('    var o = {};');
      console.log('    mod_obj.__ms_js_to_c_api__ = o;');
      console.log('    mod_obj.__ms_this__ = ths;');
      console.log('    return o;');
      console.log('  }');
      
      console.log('};');
      console.log('');
      
      console.log('module.exports.submodules = ' + JSON.stringify(config.submodules) + ';');
      console.log('');
    }
    
    function write_make_rules() {
    
      var deps = ' $(ms.API_FILE)';
      config.js_to_c_files.forEach((file_name) => {
        deps += ' ' + path.join(path.dirname(argv.config_file), file_name);
      });
      config.c_to_js_files.forEach((file_name) => {
        deps += ' ' + path.join(path.dirname(argv.config_file), file_name);
      });
    
      console.log('');
      console.log('$(ms.INTERMEDIATE_DIR)/auto_gen/interface_glue.cpp: $(ms.this_make_dir)mutantspider_js_to_c_dispatch_stub.cpp' + deps);
      console.log('\t@mkdir -p $(@D)');
      console.log('\t@cat $(ms.this_make_dir)mutantspider_js_to_c_dispatch_stub.cpp > $@');
      console.log('\t@node $(ms.this_make_dir)/msbind.js $(ms.API_FILE) --config_file=$(ms.API_FILE) --task=write_c_snippet >> $@');
      console.log('');

      console.log('$(ms.INTERMEDIATE_DIR)/auto_gen/library_glue.js:' + deps);
      console.log('\t@mkdir -p $(@D)');
      console.log('\t@node $(ms.this_make_dir)/msbind.js $(ms.API_FILE) --config_file=$(ms.API_FILE) --task=write_js_library > $@');
      console.log('');
      
      console.log('node_modules/' + argv.component_name + '-bind/' + argv.component_name + '-bind.js:' + deps);
      console.log('\t@mkdir -p $(@D)');
      console.log('\t@node $(ms.this_make_dir)/msbind.js $(ms.API_FILE) --config_file=$(ms.API_FILE) --task=write_bind > $@');
      console.log('\t@echo "{" > $(@D)/package.json');
      console.log('\t@echo "  \\"name\\": \\"' + argv.component_name + '-bind\\"," >> $(@D)/package.json');
      console.log('\t@echo "  \\"version\\": \\"0.0.1\\"," >> $(@D)/package.json');
      console.log('\t@echo "  \\"readme\\": \\"nothing to see...\\"," >> $(@D)/package.json');
      console.log('\t@echo "  \\"description\\": \\"nothing to say...\\"," >> $(@D)/package.json');
      console.log('\t@echo "  \\"repository\\": {\\"type\\":\\"git\\", \\"url\\":\\"git@git.madeup.com:auto/madeup.git\\"}," >> $(@D)/package.json');
      console.log('\t@echo "  \\"main\\": \\"' + argv.component_name + '-bind.js' + '\\"," >> $(@D)/package.json');
      console.log('\t@echo "  \\"author\\": \\"shakespeare\\"," >> $(@D)/package.json');
      console.log('\t@echo "  \\"license\\": \\"ISC\\"," >> $(@D)/package.json');
      console.log('\t@echo "  \\"dependencies\\": {}" >> $(@D)/package.json');
      console.log('\t@echo "}" >> $(@D)/package.json');
      console.log('');
      
      console.log('');
    
    }
    
    function write_em_exports() {
      let str = 'main malloc free';
      exported_c_functions.forEach((f) => {
         str += ' ' + f.name;
      });
      console.log(str);
    }
    
    //////////////////////////////////////
    
    let config = JSON.parse(config_str);
    
    do_file_set(config.js_to_c_files, config.exported_c_functions, true, exported_c_functions);
    do_file_set(config.c_to_js_files, config.exported_js_functions, false, exported_js_functions);
    
    if (argv.task === 'write_c_snippet')
      write_c_snippet();
    else if (argv.task === 'write_js_library')
      write_js_library();
    else if (argv.task === 'write_bind')
      write_bind();
    else if (argv.task === 'write_make_rules')
      write_make_rules();
    else if (argv.task === 'write_em_exports')
      write_em_exports();

  } catch(err) {
    do_assert(err);
  }

});


